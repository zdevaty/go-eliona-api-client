/*
Eliona REST API

The Eliona REST PI enables unified access to the resources and data of an Eliona environment.

API version: 2.9.1
Contact: hello@eliona.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// DataAPIService DataAPI service
type DataAPIService service

type ApiGetDataRequest struct {
	ctx           context.Context
	ApiService    *DataAPIService
	assetId       *int32
	parentAssetId *int32
	dataSubtype   *string
	assetTypeName *string
}

// Filter for a specific asset id
func (r ApiGetDataRequest) AssetId(assetId int32) ApiGetDataRequest {
	r.assetId = &assetId
	return r
}

// Filter for a specific parent asset id
func (r ApiGetDataRequest) ParentAssetId(parentAssetId int32) ApiGetDataRequest {
	r.parentAssetId = &parentAssetId
	return r
}

// Filter for a specific type of asset data
func (r ApiGetDataRequest) DataSubtype(dataSubtype string) ApiGetDataRequest {
	r.dataSubtype = &dataSubtype
	return r
}

// Filter the name of the asset type
func (r ApiGetDataRequest) AssetTypeName(assetTypeName string) ApiGetDataRequest {
	r.assetTypeName = &assetTypeName
	return r
}

func (r ApiGetDataRequest) Execute() ([]Data, *http.Response, error) {
	return r.ApiService.GetDataExecute(r)
}

/*
GetData Gets all data

Gets information about data for assets.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDataRequest
*/
func (a *DataAPIService) GetData(ctx context.Context) ApiGetDataRequest {
	return ApiGetDataRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Data
func (a *DataAPIService) GetDataExecute(r ApiGetDataRequest) ([]Data, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Data
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.GetData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	}
	if r.parentAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentAssetId", r.parentAssetId, "form", "")
	}
	if r.dataSubtype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSubtype", r.dataSubtype, "form", "")
	}
	if r.assetTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetTypeName", r.assetTypeName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataAggregatedRequest struct {
	ctx               context.Context
	ApiService        *DataAPIService
	fromDate          *string
	toDate            *string
	assetId           *int32
	dataSubtype       *string
	assetTypeName     *string
	aggregationId     *int32
	aggregationRaster *string
}

// Filter by lower date time (RFC3339) limit inclusive
func (r ApiGetDataAggregatedRequest) FromDate(fromDate string) ApiGetDataAggregatedRequest {
	r.fromDate = &fromDate
	return r
}

// Filter by upper date time (RFC3339) limit exclusive
func (r ApiGetDataAggregatedRequest) ToDate(toDate string) ApiGetDataAggregatedRequest {
	r.toDate = &toDate
	return r
}

// Filter for a specific asset id
func (r ApiGetDataAggregatedRequest) AssetId(assetId int32) ApiGetDataAggregatedRequest {
	r.assetId = &assetId
	return r
}

// Filter for a specific type of asset data
func (r ApiGetDataAggregatedRequest) DataSubtype(dataSubtype string) ApiGetDataAggregatedRequest {
	r.dataSubtype = &dataSubtype
	return r
}

// Filter the name of the asset type
func (r ApiGetDataAggregatedRequest) AssetTypeName(assetTypeName string) ApiGetDataAggregatedRequest {
	r.assetTypeName = &assetTypeName
	return r
}

// Filter for a specific aggregation id
func (r ApiGetDataAggregatedRequest) AggregationId(aggregationId int32) ApiGetDataAggregatedRequest {
	r.aggregationId = &aggregationId
	return r
}

// Aggregation calculation interval
func (r ApiGetDataAggregatedRequest) AggregationRaster(aggregationRaster string) ApiGetDataAggregatedRequest {
	r.aggregationRaster = &aggregationRaster
	return r
}

func (r ApiGetDataAggregatedRequest) Execute() ([]DataAggregated, *http.Response, error) {
	return r.ApiService.GetDataAggregatedExecute(r)
}

/*
GetDataAggregated Get aggregated data

Deprecated: Use the 'GET /data-trend-aggregated' endpoint to retrieve aggregated data for periodic rasters without defining aggregations.
Gets aggregated data sets which combines a set of data points for a defined periodical raster.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDataAggregatedRequest

Deprecated
*/
func (a *DataAPIService) GetDataAggregated(ctx context.Context) ApiGetDataAggregatedRequest {
	return ApiGetDataAggregatedRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []DataAggregated
//
// Deprecated
func (a *DataAPIService) GetDataAggregatedExecute(r ApiGetDataAggregatedRequest) ([]DataAggregated, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DataAggregated
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.GetDataAggregated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-aggregated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "form", "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "form", "")
	}
	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	}
	if r.dataSubtype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSubtype", r.dataSubtype, "form", "")
	}
	if r.assetTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetTypeName", r.assetTypeName, "form", "")
	}
	if r.aggregationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregationId", r.aggregationId, "form", "")
	}
	if r.aggregationRaster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregationRaster", r.aggregationRaster, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataTrendAggregatedByIdRequest struct {
	ctx               context.Context
	ApiService        *DataAPIService
	assetId           int32
	dataSubtype       *string
	attributeName     *string
	aggregationRaster *string
	fromDate          *string
	toDate            *string
	sumMethod         *string
	offset            *int32
	size              *int32
}

// Type of asset data
func (r ApiGetDataTrendAggregatedByIdRequest) DataSubtype(dataSubtype string) ApiGetDataTrendAggregatedByIdRequest {
	r.dataSubtype = &dataSubtype
	return r
}

// Data attribute name
func (r ApiGetDataTrendAggregatedByIdRequest) AttributeName(attributeName string) ApiGetDataTrendAggregatedByIdRequest {
	r.attributeName = &attributeName
	return r
}

// Aggregation calculation period
func (r ApiGetDataTrendAggregatedByIdRequest) AggregationRaster(aggregationRaster string) ApiGetDataTrendAggregatedByIdRequest {
	r.aggregationRaster = &aggregationRaster
	return r
}

// Lower date time (RFC3339) limit inclusive
func (r ApiGetDataTrendAggregatedByIdRequest) FromDate(fromDate string) ApiGetDataTrendAggregatedByIdRequest {
	r.fromDate = &fromDate
	return r
}

// Upper date time (RFC3339) limit inclusive
func (r ApiGetDataTrendAggregatedByIdRequest) ToDate(toDate string) ApiGetDataTrendAggregatedByIdRequest {
	r.toDate = &toDate
	return r
}

// Method for summarize data
func (r ApiGetDataTrendAggregatedByIdRequest) SumMethod(sumMethod string) ApiGetDataTrendAggregatedByIdRequest {
	r.sumMethod = &sumMethod
	return r
}

// Specifies the starting point for pagination by indicating the number of items to skip.
func (r ApiGetDataTrendAggregatedByIdRequest) Offset(offset int32) ApiGetDataTrendAggregatedByIdRequest {
	r.offset = &offset
	return r
}

// Specifies the number of items per page for pagination.
func (r ApiGetDataTrendAggregatedByIdRequest) Size(size int32) ApiGetDataTrendAggregatedByIdRequest {
	r.size = &size
	return r
}

func (r ApiGetDataTrendAggregatedByIdRequest) Execute() ([]DataTrendAggregated, *http.Response, error) {
	return r.ApiService.GetDataTrendAggregatedByIdExecute(r)
}

/*
GetDataTrendAggregatedById Get aggregated trend of historical data

Gets aggregated trend of historical data for a period and time grid for an asset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param assetId The id of the asset
	@return ApiGetDataTrendAggregatedByIdRequest
*/
func (a *DataAPIService) GetDataTrendAggregatedById(ctx context.Context, assetId int32) ApiGetDataTrendAggregatedByIdRequest {
	return ApiGetDataTrendAggregatedByIdRequest{
		ApiService: a,
		ctx:        ctx,
		assetId:    assetId,
	}
}

// Execute executes the request
//
//	@return []DataTrendAggregated
func (a *DataAPIService) GetDataTrendAggregatedByIdExecute(r ApiGetDataTrendAggregatedByIdRequest) ([]DataTrendAggregated, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DataTrendAggregated
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.GetDataTrendAggregatedById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-trend-aggregated/{asset-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"asset-id"+"}", url.PathEscape(parameterValueToString(r.assetId, "assetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataSubtype == nil {
		return localVarReturnValue, nil, reportError("dataSubtype is required and must be specified")
	}
	if r.attributeName == nil {
		return localVarReturnValue, nil, reportError("attributeName is required and must be specified")
	}
	if r.aggregationRaster == nil {
		return localVarReturnValue, nil, reportError("aggregationRaster is required and must be specified")
	}
	if r.fromDate == nil {
		return localVarReturnValue, nil, reportError("fromDate is required and must be specified")
	}
	if r.toDate == nil {
		return localVarReturnValue, nil, reportError("toDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "dataSubtype", r.dataSubtype, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", r.attributeName, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "aggregationRaster", r.aggregationRaster, "form", "")
	if r.sumMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sumMethod", r.sumMethod, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "form", "")
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataTrendByIdRequest struct {
	ctx           context.Context
	ApiService    *DataAPIService
	assetId       int32
	dataSubtype   *string
	attributeName *string
	fromDate      *string
	toDate        *string
	offset        *int32
	size          *int32
}

// Type of asset data
func (r ApiGetDataTrendByIdRequest) DataSubtype(dataSubtype string) ApiGetDataTrendByIdRequest {
	r.dataSubtype = &dataSubtype
	return r
}

// Data attribute name
func (r ApiGetDataTrendByIdRequest) AttributeName(attributeName string) ApiGetDataTrendByIdRequest {
	r.attributeName = &attributeName
	return r
}

// Lower date time (RFC3339) limit inclusive
func (r ApiGetDataTrendByIdRequest) FromDate(fromDate string) ApiGetDataTrendByIdRequest {
	r.fromDate = &fromDate
	return r
}

// Upper date time (RFC3339) limit inclusive
func (r ApiGetDataTrendByIdRequest) ToDate(toDate string) ApiGetDataTrendByIdRequest {
	r.toDate = &toDate
	return r
}

// Specifies the starting point for pagination by indicating the number of items to skip.
func (r ApiGetDataTrendByIdRequest) Offset(offset int32) ApiGetDataTrendByIdRequest {
	r.offset = &offset
	return r
}

// Specifies the number of items per page for pagination.
func (r ApiGetDataTrendByIdRequest) Size(size int32) ApiGetDataTrendByIdRequest {
	r.size = &size
	return r
}

func (r ApiGetDataTrendByIdRequest) Execute() ([]Data, *http.Response, error) {
	return r.ApiService.GetDataTrendByIdExecute(r)
}

/*
GetDataTrendById Get trend of historical data

Gets trend information about historical data for an asset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param assetId The id of the asset
	@return ApiGetDataTrendByIdRequest
*/
func (a *DataAPIService) GetDataTrendById(ctx context.Context, assetId int32) ApiGetDataTrendByIdRequest {
	return ApiGetDataTrendByIdRequest{
		ApiService: a,
		ctx:        ctx,
		assetId:    assetId,
	}
}

// Execute executes the request
//
//	@return []Data
func (a *DataAPIService) GetDataTrendByIdExecute(r ApiGetDataTrendByIdRequest) ([]Data, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Data
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.GetDataTrendById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-trend/{asset-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"asset-id"+"}", url.PathEscape(parameterValueToString(r.assetId, "assetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataSubtype == nil {
		return localVarReturnValue, nil, reportError("dataSubtype is required and must be specified")
	}
	if r.attributeName == nil {
		return localVarReturnValue, nil, reportError("attributeName is required and must be specified")
	}
	if r.fromDate == nil {
		return localVarReturnValue, nil, reportError("fromDate is required and must be specified")
	}
	if r.toDate == nil {
		return localVarReturnValue, nil, reportError("toDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "dataSubtype", r.dataSubtype, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "attributeName", r.attributeName, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "form", "")
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataTrendsRequest struct {
	ctx           context.Context
	ApiService    *DataAPIService
	fromDate      *string
	toDate        *string
	assetId       *int32
	dataSubtype   *string
	assetTypeName *string
}

// Filter by lower date time (RFC3339) limit inclusive
func (r ApiGetDataTrendsRequest) FromDate(fromDate string) ApiGetDataTrendsRequest {
	r.fromDate = &fromDate
	return r
}

// Filter by upper date time (RFC3339) limit exclusive
func (r ApiGetDataTrendsRequest) ToDate(toDate string) ApiGetDataTrendsRequest {
	r.toDate = &toDate
	return r
}

// Filter for a specific asset id
func (r ApiGetDataTrendsRequest) AssetId(assetId int32) ApiGetDataTrendsRequest {
	r.assetId = &assetId
	return r
}

// Filter for a specific type of asset data
func (r ApiGetDataTrendsRequest) DataSubtype(dataSubtype string) ApiGetDataTrendsRequest {
	r.dataSubtype = &dataSubtype
	return r
}

// Filter the name of the asset type
func (r ApiGetDataTrendsRequest) AssetTypeName(assetTypeName string) ApiGetDataTrendsRequest {
	r.assetTypeName = &assetTypeName
	return r
}

func (r ApiGetDataTrendsRequest) Execute() ([]Data, *http.Response, error) {
	return r.ApiService.GetDataTrendsExecute(r)
}

/*
GetDataTrends Get trend of historical data

Deprecated: Use 'GET /data-trend/{asset-id}' instead.
Gets trend information about historical data for assets.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDataTrendsRequest

Deprecated
*/
func (a *DataAPIService) GetDataTrends(ctx context.Context) ApiGetDataTrendsRequest {
	return ApiGetDataTrendsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Data
//
// Deprecated
func (a *DataAPIService) GetDataTrendsExecute(r ApiGetDataTrendsRequest) ([]Data, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Data
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.GetDataTrends")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-trends"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "form", "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "form", "")
	}
	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	}
	if r.dataSubtype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSubtype", r.dataSubtype, "form", "")
	}
	if r.assetTypeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetTypeName", r.assetTypeName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListenDataRequest struct {
	ctx         context.Context
	ApiService  *DataAPIService
	assetId     *int32
	dataSubtype *string
}

// Filter for a specific asset id
func (r ApiListenDataRequest) AssetId(assetId int32) ApiListenDataRequest {
	r.assetId = &assetId
	return r
}

// Filter for a specific type of asset data
func (r ApiListenDataRequest) DataSubtype(dataSubtype string) ApiListenDataRequest {
	r.dataSubtype = &dataSubtype
	return r
}

func (r ApiListenDataRequest) Execute() (*DataListen, *http.Response, error) {
	return r.ApiService.ListenDataExecute(r)
}

/*
ListenData WebSocket connection for asset data changes

Open a WebSocket connection to get informed when new asset data is written or anything changes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListenDataRequest
*/
func (a *DataAPIService) ListenData(ctx context.Context) ApiListenDataRequest {
	return ApiListenDataRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DataListen
func (a *DataAPIService) ListenDataExecute(r ApiListenDataRequest) (*DataListen, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataListen
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.ListenData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-listener"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	}
	if r.dataSubtype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSubtype", r.dataSubtype, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutBulkDataRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	data       *[]Data
	directMode *string
}

func (r ApiPutBulkDataRequest) Data(data []Data) ApiPutBulkDataRequest {
	r.data = &data
	return r
}

// Executes the operation directly without using other services.
func (r ApiPutBulkDataRequest) DirectMode(directMode string) ApiPutBulkDataRequest {
	r.directMode = &directMode
	return r
}

func (r ApiPutBulkDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutBulkDataExecute(r)
}

/*
PutBulkData Create or update multiple asset data

Create multiple asset data or update data if already exists. Uses the unique combination of asset id and subtype for updating.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutBulkDataRequest
*/
func (a *DataAPIService) PutBulkData(ctx context.Context) ApiPutBulkDataRequest {
	return ApiPutBulkDataRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) PutBulkDataExecute(r ApiPutBulkDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.PutBulkData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return nil, reportError("data is required and must be specified")
	}

	if r.directMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directMode", r.directMode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutDataRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	data       *Data
	directMode *string
}

func (r ApiPutDataRequest) Data(data Data) ApiPutDataRequest {
	r.data = &data
	return r
}

// Executes the operation directly without using other services.
func (r ApiPutDataRequest) DirectMode(directMode string) ApiPutDataRequest {
	r.directMode = &directMode
	return r
}

func (r ApiPutDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutDataExecute(r)
}

/*
PutData Create or update asset data

Create new asset data or update data if already exists. Uses the unique combination of asset id and subtype for updating.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutDataRequest
*/
func (a *DataAPIService) PutData(ctx context.Context) ApiPutDataRequest {
	return ApiPutDataRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DataAPIService) PutDataExecute(r ApiPutDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.PutData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return nil, reportError("data is required and must be specified")
	}

	if r.directMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directMode", r.directMode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutDataTrendRequest struct {
	ctx        context.Context
	ApiService *DataAPIService
	data       *Data
}

func (r ApiPutDataTrendRequest) Data(data Data) ApiPutDataTrendRequest {
	r.data = &data
	return r
}

func (r ApiPutDataTrendRequest) Execute() (*Data, *http.Response, error) {
	return r.ApiService.PutDataTrendExecute(r)
}

/*
PutDataTrend Create or update historical data

This creates or updates historical data. The choice between updating or creating depends on whether the historical
data for assetId, subtype, parameter and timestamp already exists.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutDataTrendRequest
*/
func (a *DataAPIService) PutDataTrend(ctx context.Context) ApiPutDataTrendRequest {
	return ApiPutDataTrendRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Data
func (a *DataAPIService) PutDataTrendExecute(r ApiPutDataTrendRequest) (*Data, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Data
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAPIService.PutDataTrend")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-trend"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
